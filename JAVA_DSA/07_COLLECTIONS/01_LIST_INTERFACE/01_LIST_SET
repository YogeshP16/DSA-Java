What is a List?
A List is an ordered collection in Java that:

Maintains insertion order.
Allows duplicate elements.
Provides indexed access to elements.


Implementations of the List Interface

ArrayList

Backed by a dynamic array.
Fast for random access (get() and set() are O(1)).
Slower for insertions/deletions in the middle (shifting required).

LinkedList

Backed by a doubly-linked list.
Fast for insertions/deletions anywhere (add() and remove() are O(1) for iterators).
Slower for random access (get() is O(n)).

Vector

Synchronized version of ArrayList (not commonly used now).
Thread-safe but slower due to synchronization overhead.


Key Methods in the List Interface

Method	                        Description	Example
add(E e)	                    Appends an element to the list.	                       list.add("apple");
add(int index, E element)	    Inserts an element at a specific index.	               list.add(1, "banana");
get(int index)	                Retrieves the element at a specific index.	           String fruit = list.get(0);
set(int index, E element)	    Replaces the element at a specific index.	           list.set(0, "grape");
remove(int index)	            Removes the element at a specific index.	           list.remove(0);
remove(Object o)	            Removes the first occurrence of the specified element. list.remove("apple");
size()	                        Returns the number of elements in the list.	           int size = list.size();
contains(Object o)	            Checks if the list contains a specific element.	       boolean hasApple = list.contains("apple");
indexOf(Object o)	            Returns the index of the first occurrence.	           int index = list.indexOf("banana");
lastIndexOf(Object o)	        Returns the index of the last occurrence.	           int lastIndex = list.lastIndexOf("banana");
clear()	                        Removes all elements from the list.	                   list.clear();
isEmpty()	                    Checks if the list is empty.	                       boolean empty = list.isEmpty();
subList(int fromIndex, int toIndex)	Returns a view of a portion of the list.	       List<String> sub = list.subList(1, 3);Differences Between ArrayList and LinkedList


Feature	                      ArrayList	                        LinkedList
Storage	                      Dynamic array.	                Doubly-linked list.
Access Speed	              Fast (O(1)).	                    Slower (O(n)).
Insertion/Deletion	          Slower in the middle (O(n)).	    Fast in the middle (O(1) if iterator is used).
Memory Usage	              Less (array overhead only).	    More (node objects required).


Thread-Safe Alternatives

CopyOnWriteArrayList (from java.util.concurrent):

Thread-safe alternative to ArrayList.
Performs a copy of the underlying array on each modification, making it slower for writes but fast for reads.
Collections.synchronizedList(List):

Wraps any list in a synchronized wrapper.

Example:

java
Copy code
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;

public class ThreadSafeExample {
    public static void main(String[] args) {
        List<String> list = Collections.synchronizedList(new ArrayList<>());
        
        list.add("Thread");
        list.add("Safe");
    }
}
Common Use Cases for List
Dynamic-sized arrays (ArrayList is most commonly used).
Insert/delete operations at arbitrary positions (LinkedList is better).
Thread-safe scenarios (CopyOnWriteArrayList or Vector).

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

What is a Set?
A Set is a collection in Java that:

Does not allow duplicate elements.
Does not guarantee insertion order (except in specific implementations).
Provides operations for mathematical set theory (union, intersection, etc.).

Implementations of the Set Interface

HashSet

Backed by a HashMap.
Fast for add, remove, and contains operations (O(1) average).
Does not preserve insertion order.

LinkedHashSet

Extends HashSet.
Preserves insertion order.
Slightly slower than HashSet due to the additional ordering overhead.

TreeSet

Backed by a TreeMap.
Stores elements in sorted (ascending) order.
Slower than HashSet for most operations (O(log n) due to tree structure).

EnumSet

Specialized for enums.
Very efficient for fixed set of constants.


Key Methods in the Set Interface

Method	            Description                  	            Example

add(E e)	        Adds an element to the set.	                set.add("apple");
remove(Object o)	Removes the specified element.	            set.remove("apple");
contains(Object o)	Checks if the set contains the specified element.	boolean exists = set.contains("apple");
size()	            Returns the number of elements in the set.	int size = set.size();
isEmpty()	        Checks if the set is empty.	                boolean empty = set.isEmpty();
clear()	            Removes all elements from the set.	        set.clear();
iterator()	        Returns an iterator for the set.	        Iterator<String> itr = set.iterator();

Thread-Safe Alternatives

Collections.synchronizedSet(Set):

Wraps a set in a synchronized wrapper.

Example:

java
Copy code
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public class ThreadSafeSet {
    public static void main(String[] args) {
        Set<String> set = Collections.synchronizedSet(new HashSet<>());
        set.add("Thread-Safe");
    }
}
ConcurrentSkipListSet (from java.util.concurrent):

Thread-safe and maintains elements in sorted order.


Special Features of Set

No Duplicates:
If an element already exists, add(E e) does not add it again and returns false.

Mathematical Set Operations:
Union: Combine two sets.
Intersection: Common elements between two sets.

Difference: Elements present in one set but not the other.
Example:

java
Copy code
import java.util.HashSet;
import java.util.Set;

public class SetOperations {
    public static void main(String[] args) {
        Set<Integer> set1 = new HashSet<>();
        set1.add(1);
        set1.add(2);
        set1.add(3);

        Set<Integer> set2 = new HashSet<>();
        set2.add(2);
        set2.add(3);
        set2.add(4);

        // Union
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("Union: " + union); // Output: [1, 2, 3, 4]

        // Intersection
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("Intersection: " + intersection); // Output: [2, 3]

        // Difference
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("Difference: " + difference); // Output: [1]
    }
}


Common Use Cases for Set
Removing duplicates from a collection.
Storing unique items.
Fast lookups for membership testing (contains).
Implementing mathematical operations like union and intersection.